# -*- coding: utf-8 -*-
"""plant cnn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ytvcCRsoT6rWB_1XxQqySy3tlrm_l6ug
"""

from google.colab import drive
drive.mount('/content/drive',force_remount=True)

import torch
import torchvision
from torchvision import datasets, transforms
from torch import nn, optim
from torch.utils.data import DataLoader
from sklearn.metrics import accuracy_score, classification_report


# Data Preprocessing
transformation = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

train_data = datasets.ImageFolder(root="/content/drive/MyDrive/plant dataset/train", transform=transformation)
test_data = datasets.ImageFolder(root="/content/drive/MyDrive/plant dataset/test", transform=transformation)

train_loader = DataLoader(train_data, batch_size=64, shuffle=True)  # Reduced batch size
test_loader = DataLoader(test_data, batch_size=64, shuffle=True)
class_names = train_data.classes
# Model Definition
class PlantDiseasesCNN(nn.Module):
    def __init__(self):
        super(PlantDiseasesCNN, self).__init__()
        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1)
        self.pool_1 = nn.MaxPool2d(kernel_size=2, stride=2)
        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1)
        self.pool_2 = nn.AvgPool2d(kernel_size=2, stride=2)
        self.conv3 = nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3)
        self.pool_3 = nn.MaxPool2d(kernel_size=2, stride=2)

        # Dynamically calculate the input neurons
        self._to_linear = None
        self._get_conv_output()

        self.fc1 = nn.Linear(self._to_linear, 512)
        self.fc2 = nn.Linear(512, 256)
        self.fc3 = nn.Linear(256, 128)
        self.fc4 = nn.Linear(128, 64)
        self.fc5 = nn.Linear(64, 38) 
        self.dropout = nn.Dropout(0.2)
        self.relu = nn.ReLU()

    def _get_conv_output(self):
        dummy_input = torch.randn(1, 3, 224, 224)  
        out = self.conv1(dummy_input)
        out = self.pool_1(out)
        out = self.conv2(out)
        out = self.pool_2(out)
        out = self.conv3(out)
        out = self.pool_3(out)
        self._to_linear = out.numel()  

    def forward(self, x):
        x = self.pool_1(self.conv1(x))
        x = self.pool_2(self.conv2(x))
        x = self.pool_3(self.conv3(x))

        x = x.view(-1, self._to_linear)  
        x = self.relu(self.fc1(x))
        x = self.dropout(x)  
        x = self.relu(self.fc2(x))
        x = self.relu(self.fc3(x))
        x = self.relu(self.fc4(x))
        x = self.fc5(x)  
        return x

# Initialize Model
model = PlantDiseasesCNN()

# Move Model to GPU (if available)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Loss Function and Optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.0001, weight_decay=0.0001)  
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1)

# Training Loop
num_epochs = 20
for epoch in range(1, num_epochs + 1):
    total_loss = 0
    model.train() 
    for imgs, labels in train_loader:
        imgs, labels = imgs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(imgs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    scheduler.step()  
    print(f"Epoch {epoch}/{num_epochs}, Loss: {total_loss:.4f}")

# Testing Loop
model.eval()  
correct_predictions = 0
total_samples = 0
total_loss = 0
all_preds = []
all_labels = []

with torch.no_grad():
    for imgs, labels in test_loader:
        imgs, labels = imgs.to(device), labels.to(device)
        outputs = model(imgs)
        loss = criterion(outputs, labels)
        total_loss += loss.item()
        _, predictions = torch.max(outputs, 1)
        total_samples += labels.size(0)
        correct_predictions += (predictions == labels).sum().item()
        all_preds.extend(predictions.cpu().numpy())
        all_labels.extend(labels.numpy())

accuracy = correct_predictions / total_samples
print(f'Accuracy of model: {accuracy * 100:.2f}%')
print(f"Total test data loss: {total_loss:.4f}")
print(classification_report(all_labels, all_preds, target_names=class_names))

# Save the model
torch.save(model.state_dict(), 'plant_disease_model.pth')

from google.colab import files
files.download('plant_disease_model.pth')

